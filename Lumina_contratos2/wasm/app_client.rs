// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct AppFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> AppFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::AppFactory for AppFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, app_factory::io::New>::new(self.remoting.clone(), ())
    }
}

pub mod app_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct Service<R> {
    remoting: R,
}
impl<R> Service<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Service for Service<R> {
    type Args = R::Args;
    fn add_funds(&mut self, amount: u64) -> impl Call<Output = Events, Args = R::Args> {
        RemotingAction::<_, service::io::AddFunds>::new(self.remoting.clone(), amount)
    }
    fn calculate_borrowers(&mut self) -> impl Call<Output = Events, Args = R::Args> {
        RemotingAction::<_, service::io::CalculateBorrowers>::new(self.remoting.clone(), ())
    }
    fn distribute_funds(
        &mut self,
        amount: u64,
        category: String,
    ) -> impl Call<Output = Events, Args = R::Args> {
        RemotingAction::<_, service::io::DistributeFunds>::new(
            self.remoting.clone(),
            (amount, category),
        )
    }
    fn get_avg_amount(&self, category: String) -> impl Query<Output = Option<u64>, Args = R::Args> {
        RemotingAction::<_, service::io::GetAvgAmount>::new(self.remoting.clone(), category)
    }
    fn get_borrowers_by_category(
        &self,
        category: String,
    ) -> impl Query<Output = Vec<Borrower>, Args = R::Args> {
        RemotingAction::<_, service::io::GetBorrowersByCategory>::new(
            self.remoting.clone(),
            category,
        )
    }
    fn get_lenders(&self) -> impl Query<Output = Vec<Lender>, Args = R::Args> {
        RemotingAction::<_, service::io::GetLenders>::new(self.remoting.clone(), ())
    }
    fn query(&self) -> impl Query<Output = IoState, Args = R::Args> {
        RemotingAction::<_, service::io::Query>::new(self.remoting.clone(), ())
    }
}

pub mod service {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddFunds(());
        impl AddFunds {
            #[allow(dead_code)]
            pub fn encode_call(amount: u64) -> Vec<u8> {
                <AddFunds as ActionIo>::encode_call(&amount)
            }
        }
        impl ActionIo for AddFunds {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 32, 65, 100, 100, 70, 117, 110, 100, 115,
            ];
            type Params = u64;
            type Reply = super::Events;
        }
        pub struct CalculateBorrowers(());
        impl CalculateBorrowers {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <CalculateBorrowers as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for CalculateBorrowers {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 72, 67, 97, 108, 99, 117, 108, 97, 116, 101,
                66, 111, 114, 114, 111, 119, 101, 114, 115,
            ];
            type Params = ();
            type Reply = super::Events;
        }
        pub struct DistributeFunds(());
        impl DistributeFunds {
            #[allow(dead_code)]
            pub fn encode_call(amount: u64, category: String) -> Vec<u8> {
                <DistributeFunds as ActionIo>::encode_call(&(amount, category))
            }
        }
        impl ActionIo for DistributeFunds {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 60, 68, 105, 115, 116, 114, 105, 98, 117, 116,
                101, 70, 117, 110, 100, 115,
            ];
            type Params = (u64, String);
            type Reply = super::Events;
        }
        pub struct GetAvgAmount(());
        impl GetAvgAmount {
            #[allow(dead_code)]
            pub fn encode_call(category: String) -> Vec<u8> {
                <GetAvgAmount as ActionIo>::encode_call(&category)
            }
        }
        impl ActionIo for GetAvgAmount {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 48, 71, 101, 116, 65, 118, 103, 65, 109, 111,
                117, 110, 116,
            ];
            type Params = String;
            type Reply = Option<u64>;
        }
        pub struct GetBorrowersByCategory(());
        impl GetBorrowersByCategory {
            #[allow(dead_code)]
            pub fn encode_call(category: String) -> Vec<u8> {
                <GetBorrowersByCategory as ActionIo>::encode_call(&category)
            }
        }
        impl ActionIo for GetBorrowersByCategory {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 88, 71, 101, 116, 66, 111, 114, 114, 111, 119,
                101, 114, 115, 66, 121, 67, 97, 116, 101, 103, 111, 114, 121,
            ];
            type Params = String;
            type Reply = Vec<super::Borrower>;
        }
        pub struct GetLenders(());
        impl GetLenders {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GetLenders as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GetLenders {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 40, 71, 101, 116, 76, 101, 110, 100, 101, 114,
                115,
            ];
            type Params = ();
            type Reply = Vec<super::Lender>;
        }
        pub struct Query(());
        impl Query {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Query as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Query {
            const ROUTE: &'static [u8] = &[
                28, 83, 101, 114, 118, 105, 99, 101, 20, 81, 117, 101, 114, 121,
            ];
            type Params = ();
            type Reply = super::IoState;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Events {
    FundsAdded,
    BorrowersCalculated,
    FundsDistributed,
    Error(String),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Borrower {
    pub requested_amount: u64,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Lender {
    pub amount_available: u64,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct IoState {
    pub lenders: Vec<Lender>,
    pub gold_borrowers: Vec<Borrower>,
    pub silver_borrowers: Vec<Borrower>,
    pub bronze_borrowers: Vec<Borrower>,
    pub gold_avg: Option<u64>,
    pub silver_avg: Option<u64>,
    pub bronze_avg: Option<u64>,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait AppFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Service {
        type Args;
        fn add_funds(&mut self, amount: u64) -> impl Call<Output = Events, Args = Self::Args>;
        fn calculate_borrowers(&mut self) -> impl Call<Output = Events, Args = Self::Args>;
        fn distribute_funds(
            &mut self,
            amount: u64,
            category: String,
        ) -> impl Call<Output = Events, Args = Self::Args>;
        fn get_avg_amount(
            &self,
            category: String,
        ) -> impl Query<Output = Option<u64>, Args = Self::Args>;
        fn get_borrowers_by_category(
            &self,
            category: String,
        ) -> impl Query<Output = Vec<Borrower>, Args = Self::Args>;
        fn get_lenders(&self) -> impl Query<Output = Vec<Lender>, Args = Self::Args>;
        fn query(&self) -> impl Query<Output = IoState, Args = Self::Args>;
    }
}
